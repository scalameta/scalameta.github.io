<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Tree Guide · Scalameta</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="A core functionality of Scalameta is syntax trees, which enable you to read,"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Tree Guide · Scalameta"/><meta property="og:type" content="website"/><meta property="og:url" content="https://scalameta.org/index.html"/><meta property="og:description" content="A core functionality of Scalameta is syntax trees, which enable you to read,"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"/><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/scalameta.png" alt="Scalameta"/><h2 class="headerTitleWithLogo">Scalameta</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive siteNavItemActive"><a href="/docs/trees/guide.html" target="_self">Trees</a></li><li class="siteNavGroupActive"><a href="/docs/semanticdb/guide.html" target="_self">SemanticDB</a></li><li class=""><a href="https://github.com/scalameta/scalameta" target="_blank">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Trees</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Trees</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/docs/trees/guide.html">Guide</a></li><li class="navListItem"><a class="navItem" href="/docs/trees/quasiquotes.html">trees/quasiquotes</a></li><li class="navListItem"><a class="navItem" href="/docs/trees/examples.html">trees/examples</a></li><li class="navListItem"><a class="navItem" href="/docs/trees/scalafiddle.html">ScalaFiddle Playground</a></li><li class="navListItem"><a class="navItem" href="/docs/trees/astexplorer.html">AST Explorer</a></li><li class="navListItem"><a class="navItem" href="/docs/trees/scaladoc.html">Scaladoc</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">SemanticDB</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/semanticdb/guide.html">Guide</a></li><li class="navListItem"><a class="navItem" href="/docs/semanticdb/specification.html">Specification</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Community</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/misc/built-with-scalameta.html">Built with Scalameta</a></li><li class="navListItem"><a class="navItem" href="/docs/misc/presentations.html">Presentations</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Tree Guide</h1></header><article><div><span><p>A core functionality of Scalameta is syntax trees, which enable you to read,
analyze, transform and generate Scala programs at a level of abstraction. In
this guide, you will learn how to</p>
<ul>
<li>parse source code into syntax trees</li>
<li>construct new syntax trees</li>
<li>pattern match syntax trees</li>
<li>traverse syntax trees</li>
<li>transform syntax trees</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="installation"></a><a href="#installation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Installation</h2>
<p>Add a dependency to Scalameta in your build to get started. Scalameta supports
Scala 2.11, Scala 2.12, Scala 2.13, Scala.js and Scala Native.</p>
<h3><a class="anchor" aria-hidden="true" id="sbt"></a><a href="#sbt" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>sbt</h3>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// build.sbt</span>
libraryDependencies += <span class="hljs-string">"org.scalameta"</span> %% <span class="hljs-string">"scalameta"</span> % <span class="hljs-string">"4.4.32"</span>

<span class="hljs-comment">// For Scala.js, Scala Native</span>
libraryDependencies += <span class="hljs-string">"org.scalameta"</span> %%% <span class="hljs-string">"scalameta"</span> % <span class="hljs-string">"4.4.32"</span>
</code></pre>
<p><a href="https://maven-badges.herokuapp.com/maven-central/org.scalameta/scalameta_2.12"><img src="https://maven-badges.herokuapp.com/maven-central/org.scalameta/scalameta_2.12/badge.svg" alt="Maven Central"></a></p>
<p>All code examples assume you have the following import</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scala.meta._
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="ammonite-repl"></a><a href="#ammonite-repl" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ammonite REPL</h3>
<p>A great way to experiment with Scalameta is to use the
<a href="http://ammonite.io/#Ammonite-REPL">Ammonite REPL</a>. To make it work with
scalameta it needs to be run with <code>--thin</code> option.</p>
<pre><code class="hljs css language-sh">$ amm --thin
Loading...
Welcome to the Ammonite Repl 2.3.8 (Scala 2.13.5 Java 11.0.7)
@ import <span class="hljs-variable">$ivy</span>.`org.scalameta::scalameta:4.4.32`, scala.meta._
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="scalafiddle"></a><a href="#scalafiddle" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ScalaFiddle</h3>
<p>You can try out Scalameta online with the
<a href="scalafiddle.html">ScalaFiddle playground</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="what-is-a-syntax-tree"></a><a href="#what-is-a-syntax-tree" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is a syntax tree?</h2>
<p>Syntax trees are a representation of source code that makes it easier to
programmatically analyze programs. Scalameta has syntax trees that represent
Scala programs.</p>
<p><img src="/docs/assets/tree.svg" alt=""></p>
<p>Scalameta trees are <strong>lossless</strong>, meaning that they represent Scala programs in
sufficient detail to go from text to trees and vice-versa. Lossless syntax trees
are great for fine-grained analysis of source code, which is useful for a range
of applications including formatting, refactoring, linting and documentation
tools</p>
<h2><a class="anchor" aria-hidden="true" id="parse-trees"></a><a href="#parse-trees" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Parse trees</h2>
<p>Scalameta comes with a parser to produce syntax trees from Scala source code.
You can parse trees from a variety of sources into different kinds of tree
nodes.</p>
<h3><a class="anchor" aria-hidden="true" id="from-strings"></a><a href="#from-strings" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>From strings</h3>
<p>The simplest way to parse source code is from a string. As long as you have
<code>import scala.meta._</code> in your scope, you can use the <code>parse[Source]</code> extension
method</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> program = <span class="hljs-string">""</span><span class="hljs-string">"object Main extends App { print("</span><span class="hljs-type">Hello</span>!<span class="hljs-string">") }"</span><span class="hljs-string">""</span>
<span class="hljs-keyword">val</span> tree = program.parse[<span class="hljs-type">Source</span>].get
</code></pre>
<p>Once parsed, you can print the tree back into its original source code</p>
<pre><code class="hljs css language-scala">println(tree.syntax)
<span class="hljs-comment">// object Main extends App { print("Hello!") }</span>
</code></pre>
<p>The problem with parsing from strings it that error messages don't include a
filename</p>
<pre><code class="hljs css language-scala">println(
  <span class="hljs-string">"object Main {"</span>.parse[<span class="hljs-type">Source</span>]
)
<span class="hljs-comment">// &lt;input&gt;:1: error: } expected but end of file found</span>
<span class="hljs-comment">// object Main {</span>
<span class="hljs-comment">//              ^</span>
</code></pre>
<p>To make error messages more helpful it's recommended to always use virtual files
when possible, as explained below.</p>
<h3><a class="anchor" aria-hidden="true" id="from-files"></a><a href="#from-files" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>From files</h3>
<p>To parse a file into a tree it's recommended to first read the file contents
into a string and then construct a virtual file</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> path = java.nio.file.<span class="hljs-type">Paths</span>.get(<span class="hljs-string">"docs"</span>, <span class="hljs-string">"example.scala"</span>)
<span class="hljs-keyword">val</span> bytes = java.nio.file.<span class="hljs-type">Files</span>.readAllBytes(path)
<span class="hljs-keyword">val</span> text = <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(bytes, <span class="hljs-string">"UTF-8"</span>)
<span class="hljs-keyword">val</span> input = <span class="hljs-type">Input</span>.<span class="hljs-type">VirtualFile</span>(path.toString, text)
<span class="hljs-keyword">val</span> exampleTree = input.parse[<span class="hljs-type">Source</span>].get
</code></pre>
<pre><code class="hljs css language-scala">print(exampleTree.syntax)
<span class="hljs-comment">// object Example extends App { println("Hello from a file!") }</span>
</code></pre>
<p>The difference between <code>text.parse[Source]</code> and <code>input.parse[Source]</code> is that
the filename appears in error messages for <code>Input.VirtualFile</code>.</p>
<pre><code class="hljs css language-scala">println(
  <span class="hljs-type">Input</span>.<span class="hljs-type">VirtualFile</span>(<span class="hljs-string">"example.scala"</span>, <span class="hljs-string">"object Main {"</span>).parse[<span class="hljs-type">Source</span>]
)
<span class="hljs-comment">// example.scala:1: error: } expected but end of file found</span>
<span class="hljs-comment">// object Main {</span>
<span class="hljs-comment">//              ^</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="from-expressions"></a><a href="#from-expressions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>From expressions</h3>
<p>To parse a simple expressions such as <code>a + b</code> use <code>parse[Stat]</code> The name <code>Stat</code>
stands for &quot;statement&quot;.</p>
<pre><code class="hljs css language-scala">println(<span class="hljs-string">"a + b"</span>.parse[<span class="hljs-type">Stat</span>].get.structure)
<span class="hljs-comment">// Term.ApplyInfix(Term.Name("a"), Term.Name("+"), Nil, List(Term.Name("b")))</span>
</code></pre>
<p>If we try to parse an expression with <code>parse[Source]</code> we get an error because
<code>a + b</code> is not valid at the top-level for Scala programs</p>
<pre><code class="hljs css language-scala">println(<span class="hljs-string">"a + b"</span>.parse[<span class="hljs-type">Source</span>])
<span class="hljs-comment">// &lt;input&gt;:1: error: expected class or object definition identifier</span>
<span class="hljs-comment">// a + b</span>
<span class="hljs-comment">// ^</span>
</code></pre>
<p>The same solution can be used to parse other tree nodes such as types</p>
<pre><code class="hljs css language-scala">println(<span class="hljs-string">"A with B"</span>.parse[<span class="hljs-type">Type</span>].get.structure)
<span class="hljs-comment">// Type.With(Type.Name("A"), Type.Name("B"))</span>
</code></pre>
<p>If we use <code>parse[Stat]</code> to parse types we get an error</p>
<pre><code class="hljs css language-scala">println(<span class="hljs-string">"A with B"</span>.parse[<span class="hljs-type">Stat</span>])
<span class="hljs-comment">// &lt;input&gt;:1: error: end of file expected but with found</span>
<span class="hljs-comment">// A with B</span>
<span class="hljs-comment">//   ^</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="from-programs-with-multiple-top-level-statements"></a><a href="#from-programs-with-multiple-top-level-statements" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>From programs with multiple top-level statements</h3>
<p>To parse programs with multiple top-level statements such as <code>build.sbt</code> files
or Ammonite scripts we use the <code>Sbt1</code> dialect. By default, we get an error when
using <code>parse[Source]</code>.</p>
<pre><code class="hljs css language-scala">val buildSbt = """
val core = project
val cli = project.dependsOn(core)
"""
</code></pre>
<pre><code class="hljs css language-scala">println(buildSbt.parse[<span class="hljs-type">Source</span>])
<span class="hljs-comment">// &lt;input&gt;:2: error: expected class or object definition val</span>
<span class="hljs-comment">// val core = project</span>
<span class="hljs-comment">// ^</span>
</code></pre>
<p>This error happens because vals are not allowed as top-level statements in
normal Scala programs. To fix this problem, wrap the input with <code>dialects.Sbt1</code></p>
<pre><code class="hljs css language-scala">println(dialects.<span class="hljs-type">Sbt1</span>(buildSbt).parse[<span class="hljs-type">Source</span>].get.stats)
<span class="hljs-comment">// List(val core = project, val cli = project.dependsOn(core))</span>
</code></pre>
<p>The same solution works for virtual files</p>
<pre><code class="hljs css language-scala">println(
  dialects.<span class="hljs-type">Sbt1</span>(
    <span class="hljs-type">Input</span>.<span class="hljs-type">VirtualFile</span>(<span class="hljs-string">"build.sbt"</span>, buildSbt)
  ).parse[<span class="hljs-type">Source</span>].get.stats
)
<span class="hljs-comment">// List(val core = project, val cli = project.dependsOn(core))</span>
</code></pre>
<p>The difference between <code>dialects.Sbt1(input)</code> and <code>parse[Stat]</code> is that
<code>parse[Stat]</code> does not allow multiple top-level statements</p>
<pre><code class="hljs css language-scala">println(buildSbt.parse[<span class="hljs-type">Stat</span>])
<span class="hljs-comment">// &lt;input&gt;:3: error: end of file expected but val found</span>
<span class="hljs-comment">// val cli = project.dependsOn(core)</span>
<span class="hljs-comment">// ^</span>
</code></pre>
<p>Note that <code>dialects.Sbt1</code> does not accept programs with package declarations</p>
<pre><code class="hljs css language-scala">println(
  dialects.<span class="hljs-type">Sbt1</span>(<span class="hljs-string">"package library; object Main"</span>).parse[<span class="hljs-type">Source</span>]
)
<span class="hljs-comment">// &lt;input&gt;:1: error: illegal start of definition package</span>
<span class="hljs-comment">// package library; object Main</span>
<span class="hljs-comment">// ^</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="construct-trees"></a><a href="#construct-trees" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Construct trees</h2>
<p>Sometimes we need to dynamically construct syntax trees instead of parsing them
from source code. There are two primary ways to construct trees: normal
constructors and quasiquotes.</p>
<h3><a class="anchor" aria-hidden="true" id="with-normal-constructors"></a><a href="#with-normal-constructors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>With normal constructors</h3>
<p>Normal tree constructors as plain functions</p>
<pre><code class="hljs css language-scala">println(<span class="hljs-type">Term</span>.<span class="hljs-type">Apply</span>(<span class="hljs-type">Term</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"function"</span>), <span class="hljs-type">List</span>(<span class="hljs-type">Term</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"argument"</span>))))
<span class="hljs-comment">// function(argument)</span>
</code></pre>
<p>Although normal constructors are verbose, they give most flexibility when
constructing trees.</p>
<p>To learn tree node names you can use <code>.structure</code> on existing tree nodes</p>
<pre><code class="hljs css language-scala">println(<span class="hljs-string">"function(argument)"</span>.parse[<span class="hljs-type">Stat</span>].get.structure)
<span class="hljs-comment">// Term.Apply(Term.Name("function"), List(Term.Name("argument")))</span>
</code></pre>
<p>The output of structure is safe to copy-paste into programs.</p>
<p>Another good way to learn the structure of trees is
<a href="http://astexplorer.net/#/gist/ec56167ffafb20cbd8d68f24a37043a9/97da19c8212688ceb232708b67228e3839dadc7c">AST Explorer</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="with-quasiquotes"></a><a href="#with-quasiquotes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>With quasiquotes</h3>
<p>Quasiquotes are string interpolators that expand at compile-time into normal
constructor calls</p>
<pre><code class="hljs css language-scala">println(<span class="hljs-string">q"function(argument)"</span>.structure)
<span class="hljs-comment">// Term.Apply(Term.Name("function"), List(Term.Name("argument")))</span>
</code></pre>
<p>You can write multiline quasiquotes to construct large programs</p>
<pre><code class="hljs css language-scala">println(
  q"""
  object Example extends App {
    println(42)
  }
  """.structure
)
// Defn.Object(Nil, Term.Name("Example"), Template(Nil, List(Init(Type.Name("App"), Name(""), Nil)), Self(Name(""), None), List(Term.Apply(Term.Name("println"), List(Lit.Int(42)))), Nil))
</code></pre>
<blockquote>
<p>It's important to keep in mind that quasiquotes expand at compile-time into
the same program as if you had written normal constructors by hand. This means
for example that formatting details or comments are not preserved</p>
</blockquote>
<pre><code class="hljs css language-scala">println(<span class="hljs-string">q"function  (    argument   ) // comment"</span>)
<span class="hljs-comment">// function(argument)</span>
</code></pre>
<p>Quasiquotes can be composed together like normal string interpolators with
dollar splices <code>$</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> left = <span class="hljs-string">q"Left()"</span>
<span class="hljs-comment">// left: Term.Apply = Term.Apply(</span>
<span class="hljs-comment">//   fun = Term.Name(value = "Left"),</span>
<span class="hljs-comment">//   args = List()</span>
<span class="hljs-comment">// )</span>
<span class="hljs-keyword">val</span> right = <span class="hljs-string">q"Right()"</span>
<span class="hljs-comment">// right: Term.Apply = Term.Apply(</span>
<span class="hljs-comment">//   fun = Term.Name(value = "Right"),</span>
<span class="hljs-comment">//   args = List()</span>
<span class="hljs-comment">// )</span>
println(<span class="hljs-string">q"<span class="hljs-subst">$left</span> + <span class="hljs-subst">$right</span>"</span>)
<span class="hljs-comment">// Left() + Right()</span>
</code></pre>
<p>A list of trees can be inserted into a quasiquote with double dots <code>..$</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> arguments = <span class="hljs-type">List</span>(<span class="hljs-string">q"arg1"</span>, <span class="hljs-string">q"arg2"</span>)
<span class="hljs-comment">// arguments: List[Term.Name] = List(</span>
<span class="hljs-comment">//   Term.Name(value = "arg1"),</span>
<span class="hljs-comment">//   Term.Name(value = "arg2")</span>
<span class="hljs-comment">// )</span>
println(<span class="hljs-string">q"function(..<span class="hljs-subst">$arguments</span>)"</span>)
<span class="hljs-comment">// function(arg1, arg2)</span>
</code></pre>
<p>A curried argument argument lists can be inserted into a quasiquotes with triple
dots <code>...$</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> arguments2 = <span class="hljs-type">List</span>(<span class="hljs-string">q"arg3"</span>, <span class="hljs-string">q"arg4"</span>)
<span class="hljs-comment">// arguments2: List[Term.Name] = List(</span>
<span class="hljs-comment">//   Term.Name(value = "arg3"),</span>
<span class="hljs-comment">//   Term.Name(value = "arg4")</span>
<span class="hljs-comment">// )</span>
<span class="hljs-keyword">val</span> allArguments = <span class="hljs-type">List</span>(arguments, arguments2)
<span class="hljs-comment">// allArguments: List[List[Term.Name]] = List(</span>
<span class="hljs-comment">//   List(Term.Name(value = "arg1"), Term.Name(value = "arg2")),</span>
<span class="hljs-comment">//   List(Term.Name(value = "arg3"), Term.Name(value = "arg4"))</span>
<span class="hljs-comment">// )</span>
println(<span class="hljs-string">q"function(...<span class="hljs-subst">$allArguments</span>)"</span>)
<span class="hljs-comment">// function(arg1, arg2)(arg3, arg4)</span>
</code></pre>
<p>A common mistake is to splice an empty type parameter list into type application
nodes . Imagine we have a list of type arguments that happens to be empty</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> typeArguments = <span class="hljs-type">List</span>.empty[<span class="hljs-type">Type</span>]
</code></pre>
<p>If we directly splice the lists into a type application we get a cryptic error
message &quot;invariant failed&quot;</p>
<pre><code class="hljs css language-scala"><span class="hljs-string">q"function[..<span class="hljs-subst">$typeArguments</span>]()"</span>
<span class="hljs-comment">// org.scalameta.invariants.InvariantFailedException: invariant failed:</span>
<span class="hljs-comment">// when verifying targs.!=(null).&amp;&amp;(targs.nonEmpty)</span>
<span class="hljs-comment">// found that targs.nonEmpty is false</span>
<span class="hljs-comment">// where targs = List()</span>
<span class="hljs-comment">//  at org.scalameta.invariants.InvariantFailedException$.raise(Exceptions.scala:19)</span>
<span class="hljs-comment">//  at scala.meta.Term$ApplyType$.internal$53(Trees.scala:90)</span>
<span class="hljs-comment">//  at scala.meta.Term$ApplyType$.apply(Trees.scala:90)</span>
<span class="hljs-comment">//  at repl.MdocSession$App$$anonfun$36.apply(guide.md:214)</span>
<span class="hljs-comment">//  at repl.MdocSession$App$$anonfun$36.apply(guide.md:214)</span>
</code></pre>
<p>The quasiquote above is equivalent to calling the normal constructor
<code>Type.ApplyType(.., typeArguments)</code>. Scalameta trees perform strict runtime
validation for invariants such as &quot;type application arguments must be
non-empty&quot;. To fix this problem, guard the splice against the length of the list</p>
<pre><code class="hljs css language-scala">println(
  (<span class="hljs-keyword">if</span> (typeArguments.isEmpty) <span class="hljs-string">q"function()"</span>
   <span class="hljs-keyword">else</span> <span class="hljs-string">q"function[..<span class="hljs-subst">$typeArguments</span>]()"</span>).structure
)
<span class="hljs-comment">// Term.Apply(Term.Name("function"), Nil)</span>
</code></pre>
<p>To learn more about quasiquotes, consult the
<a href="quasiquotes.html">quasiquote spec</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="pattern-match-trees"></a><a href="#pattern-match-trees" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pattern match trees</h2>
<p>Use pattern matching to target interesting tree nodes and deconstruct them. A
core design principle of Scalameta trees is that tree pattern matching is the
dual of tree construction. If you know how to construct a tree, you know how to
de-construct it.</p>
<h3><a class="anchor" aria-hidden="true" id="with-normal-constructors-1"></a><a href="#with-normal-constructors-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>With normal constructors</h3>
<p>Normal constructors work in pattern position the same way they work in regular
term position.</p>
<pre><code class="hljs css language-scala"><span class="hljs-string">"function(arg1, arg2)"</span>.parse[<span class="hljs-type">Term</span>].get <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Term</span>.<span class="hljs-type">Apply</span>(function, <span class="hljs-type">List</span>(arg1, arg2)) =&gt;
    println(<span class="hljs-string">"1 "</span> + function)
    println(<span class="hljs-string">"2 "</span> + arg1)
    println(<span class="hljs-string">"3 "</span> + arg2)
}
<span class="hljs-comment">// 1 function</span>
<span class="hljs-comment">// 2 arg1</span>
<span class="hljs-comment">// 3 arg2</span>
</code></pre>
<p>Repeated fields are always <code>List[T]</code>, so you can safely deconstruct trees with
the <code>List(arg1, arg2)</code> syntax or if you prefer the <code>arg1 :: arg2 :: Nil</code> syntax.
There is no need to use <code>Seq(arg1, arg2)</code> or <code>arg1 +: arg2 +: Nil</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="with-quasiquotes-1"></a><a href="#with-quasiquotes-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>With quasiquotes</h3>
<p>Quasiquotes expand at compile-time and work the same way in pattern position as
in term position.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Term</span>.<span class="hljs-type">Apply</span>(
  <span class="hljs-type">Term</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"function"</span>),
  <span class="hljs-type">List</span>(<span class="hljs-type">Term</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"arg1"</span>), <span class="hljs-type">Term</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"arg2"</span>))
) <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-string">q"<span class="hljs-subst">$function</span>(..<span class="hljs-subst">$args</span>)"</span> =&gt;
    println(<span class="hljs-string">"1 "</span> + function)
    println(<span class="hljs-string">"2 "</span> + args)
}
<span class="hljs-comment">// 1 function</span>
<span class="hljs-comment">// 2 List(arg1, arg2)</span>
</code></pre>
<p>Use triple dollar splices <code>...$</code> to extract curried argument lists</p>
<pre><code class="hljs css language-scala"><span class="hljs-string">"function(arg1, arg2)(arg3, arg4)"</span>.parse[<span class="hljs-type">Term</span>].get <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-string">q"<span class="hljs-subst">$function</span>(...<span class="hljs-subst">$args</span>)"</span> =&gt;
    println(<span class="hljs-string">"1 "</span> + function)
    println(<span class="hljs-string">"2 "</span> + args)
}
<span class="hljs-comment">// 1 function</span>
<span class="hljs-comment">// 2 List(List(arg1, arg2), List(arg3, arg4))</span>
</code></pre>
<blockquote>
<p>Pattern matching with quasiquotes is generally discouraged because it's easy
to write patterns that result in unintended match errors.</p>
</blockquote>
<pre><code class="hljs css language-scala"><span class="hljs-string">q"final val x = 2"</span> <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-string">q"val x = 2"</span> =&gt; <span class="hljs-comment">// boom!</span>
}
<span class="hljs-comment">// scala.MatchError: final val x = 2 (of class scala.meta.Defn$Val$DefnValImpl)</span>
<span class="hljs-comment">//  at repl.MdocSession$App$$anonfun$42.apply(guide.md:267)</span>
</code></pre>
<p>To fix this pattern, we specify that the <code>final</code> modifier should be ignored
using <code>$_</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-string">q"final val x = 2"</span> <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-string">q"<span class="hljs-subst">$_</span> val x = 2"</span> =&gt; println(<span class="hljs-string">"OK"</span>)
}
<span class="hljs-comment">// OK</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="compare-trees-for-equality"></a><a href="#compare-trees-for-equality" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Compare trees for equality</h2>
<p>Scalameta trees use reference equality by default, which may result in
surprising behavior. A common mistake is to use <code>==</code> between parsed syntax trees
and quasiquotes</p>
<pre><code class="hljs css language-scala"><span class="hljs-string">"true"</span>.parse[<span class="hljs-type">Term</span>].get == <span class="hljs-string">q"true"</span>
<span class="hljs-comment">// res26: Boolean = false</span>
</code></pre>
<p>Comparing trees by <code>==</code> is the same as comparing them with <code>eq</code>. Even identical
quasiquotes produce different references</p>
<pre><code class="hljs css language-scala"><span class="hljs-string">q"true"</span> == <span class="hljs-string">q"true"</span>
<span class="hljs-comment">// res27: Boolean = false</span>
</code></pre>
<p>Equality checks with <code>==</code> will only return true when the reference is the same.</p>
<pre><code class="hljs css language-scala">{ <span class="hljs-keyword">val</span> treeReference = <span class="hljs-string">q"true"</span>
  treeReference == treeReference }
<span class="hljs-comment">// res28: Boolean = true</span>
</code></pre>
<p>The idiomatic way to compare trees for structural equality is to use pattern
matching</p>
<pre><code class="hljs css language-scala"><span class="hljs-string">q"true"</span> <span class="hljs-keyword">match</span> { <span class="hljs-keyword">case</span> <span class="hljs-string">q"true"</span> =&gt; println(<span class="hljs-string">"YAY!"</span>) }
<span class="hljs-comment">// YAY!</span>
</code></pre>
<p>If you can't use pattern matching to compare trees by structural equality, you
can use <code>.structure</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-string">q"true"</span>.structure == <span class="hljs-string">q"true"</span>.structure
<span class="hljs-comment">// res30: Boolean = true</span>
</code></pre>
<p>The <code>.structure</code> method produces large strings for large programs, which may
become prohibitively slow. The Scalameta contrib module contains a more
efficient <code>isEqual</code> helper method to compare trees structurally.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scala.meta.contrib._
<span class="hljs-string">q"true"</span>.isEqual(<span class="hljs-string">q"true"</span>)
<span class="hljs-comment">// res31: Boolean = true</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="traverse-trees"></a><a href="#traverse-trees" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Traverse trees</h2>
<p>Scalameta includes utilities to recursively visit tree nodes for both simple and
advanced use-cases. Simple use-cases have high-level APIs that require minimal
ceremony while advanced use-cases use lower-level APIs that typically involve
more side-effects.</p>
<h3><a class="anchor" aria-hidden="true" id="simple-traversals"></a><a href="#simple-traversals" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Simple traversals</h3>
<p>Use <code>.traverse</code> to visit every tree node and perform a side-effect, similarly to
<code>.foreach</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-string">q"val x = 2"</span>.traverse {
  <span class="hljs-keyword">case</span> node =&gt;
    println(<span class="hljs-string">s"<span class="hljs-subst">${node.productPrefix}</span>: <span class="hljs-subst">$node</span>"</span>)
}
<span class="hljs-comment">// Defn.Val: val x = 2</span>
<span class="hljs-comment">// Pat.Var: x</span>
<span class="hljs-comment">// Term.Name: x</span>
<span class="hljs-comment">// Lit.Int: 2</span>
</code></pre>
<p>Use <code>.collect</code> to visit every tree node and collect a value instead of
performing a side-effect</p>
<pre><code class="hljs css language-scala"><span class="hljs-string">q"val x = 2"</span>.collect {
  <span class="hljs-keyword">case</span> node =&gt; node.productPrefix -&gt; node.toString
}
<span class="hljs-comment">// res33: List[(String, String)] = List(</span>
<span class="hljs-comment">//   ("Defn.Val", "val x = 2"),</span>
<span class="hljs-comment">//   ("Pat.Var", "x"),</span>
<span class="hljs-comment">//   ("Term.Name", "x"),</span>
<span class="hljs-comment">//   ("Lit.Int", "2")</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>The methods <code>.traverse</code> and <code>.collect</code> don't support customizing the recursion.
For more fine-grained control over which tree nodes to visit implement a custom
<code>Traverser</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="custom-traversals"></a><a href="#custom-traversals" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Custom traversals</h3>
<p>Extend <code>Traverser</code> if you need to implement a custom tree traversal</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> traverser = <span class="hljs-keyword">new</span> <span class="hljs-type">Traverser</span> {
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(tree: <span class="hljs-type">Tree</span>): <span class="hljs-type">Unit</span> = tree <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Pat</span>.<span class="hljs-type">Var</span>(name) =&gt;
      println(<span class="hljs-string">s"stop: <span class="hljs-subst">$name</span>"</span>)
    <span class="hljs-keyword">case</span> node =&gt;
      println(<span class="hljs-string">s"<span class="hljs-subst">${node.productPrefix}</span>: <span class="hljs-subst">$node</span>"</span>)
      <span class="hljs-keyword">super</span>.apply(node)
  }
}
</code></pre>
<p>The <code>super.apply(node)</code> call continues the recursion, so in this case we will
recursively visit all nodes except children of <code>Pat.Var</code> nodes.</p>
<pre><code class="hljs css language-scala">traverser(<span class="hljs-string">q"val x = 2"</span>)
<span class="hljs-comment">// Defn.Val: val x = 2</span>
<span class="hljs-comment">// stop: x</span>
<span class="hljs-comment">// Lit.Int: 2</span>
</code></pre>
<p>There is no <code>.collect</code> equivalent for custom traversals. To collect a value,
it's recommended to use <code>List.newBuilder[T]</code> for the type you are interested in
and append values inside the <code>apply</code> method.</p>
<h2><a class="anchor" aria-hidden="true" id="transform-trees"></a><a href="#transform-trees" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Transform trees</h2>
<p>Scalameta includes utilities to transform trees for simple and advanced
use-cases.</p>
<blockquote>
<p>Transformed trees do not preserve comments and formatting details when
pretty-printed. Look into <a href="https://scalacenter.github.io/scalafix/">Scalafix</a>
if you need to implement fine-grained refactorings that preserve comments and
formatting details.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="simple-transformations"></a><a href="#simple-transformations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Simple transformations</h3>
<p>Use <code>.transform</code> to visit every tree node and transform interesting tree nodes.</p>
<pre><code class="hljs css language-scala">println(
  <span class="hljs-string">q"val x = 2"</span>.transform { <span class="hljs-keyword">case</span> <span class="hljs-string">q"2"</span> =&gt; <span class="hljs-string">q"42"</span> }
)
<span class="hljs-comment">// val x = 42</span>
</code></pre>
<p>The contract of <code>.transform</code> is that it will recursively visit all tree nodes,
including the transformed trees. Due to this behavior, a common mistake is to
introduce infinite recursion in <code>.transform</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-string">q"a + b"</span>.transform {
  <span class="hljs-keyword">case</span> name @ <span class="hljs-type">Term</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"b"</span>) =&gt; <span class="hljs-string">q"function(<span class="hljs-subst">$name</span>)"</span>
}.toString
<span class="hljs-comment">// [error] java.lang.StackOverflowError</span>
<span class="hljs-comment">// at scala.meta.transversers.Api$XtensionCollectionLikeUI$transformer$2$.apply(Api.scala:10)</span>
<span class="hljs-comment">// at scala.meta.transversers.Transformer.apply(Transformer.scala:4)</span>
</code></pre>
<p>The best solution to fix this problem is to implement a custom transformer to
gain fine-grained control over the recursion.</p>
<h3><a class="anchor" aria-hidden="true" id="custom-transformations"></a><a href="#custom-transformations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Custom transformations</h3>
<p>Extend <code>Transformer</code> if you need to implement a custom tree transformation</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> transformer = <span class="hljs-keyword">new</span> <span class="hljs-type">Transformer</span> {
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(tree: <span class="hljs-type">Tree</span>): <span class="hljs-type">Tree</span> = tree <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> name @ <span class="hljs-type">Term</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"b"</span>) =&gt; <span class="hljs-string">q"function(<span class="hljs-subst">$name</span>)"</span>
    <span class="hljs-keyword">case</span> node =&gt; <span class="hljs-keyword">super</span>.apply(node)
  }
}
</code></pre>
<p>By avoiding the call to <code>super.transform</code> in the first case, we prevent a stack
overflow.</p>
<pre><code class="hljs css language-scala">println(
  transformer(<span class="hljs-string">q"a + b"</span>)
)
<span class="hljs-comment">// a + function(b)</span>
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-next button" href="/docs/trees/quasiquotes.html"><span>trees/quasiquotes</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#installation">Installation</a><ul class="toc-headings"><li><a href="#sbt">sbt</a></li><li><a href="#ammonite-repl">Ammonite REPL</a></li><li><a href="#scalafiddle">ScalaFiddle</a></li></ul></li><li><a href="#what-is-a-syntax-tree">What is a syntax tree?</a></li><li><a href="#parse-trees">Parse trees</a><ul class="toc-headings"><li><a href="#from-strings">From strings</a></li><li><a href="#from-files">From files</a></li><li><a href="#from-expressions">From expressions</a></li><li><a href="#from-programs-with-multiple-top-level-statements">From programs with multiple top-level statements</a></li></ul></li><li><a href="#construct-trees">Construct trees</a><ul class="toc-headings"><li><a href="#with-normal-constructors">With normal constructors</a></li><li><a href="#with-quasiquotes">With quasiquotes</a></li></ul></li><li><a href="#pattern-match-trees">Pattern match trees</a><ul class="toc-headings"><li><a href="#with-normal-constructors-1">With normal constructors</a></li><li><a href="#with-quasiquotes-1">With quasiquotes</a></li></ul></li><li><a href="#compare-trees-for-equality">Compare trees for equality</a></li><li><a href="#traverse-trees">Traverse trees</a><ul class="toc-headings"><li><a href="#simple-traversals">Simple traversals</a></li><li><a href="#custom-traversals">Custom traversals</a></li></ul></li><li><a href="#transform-trees">Transform trees</a><ul class="toc-headings"><li><a href="#simple-transformations">Simple transformations</a></li><li><a href="#custom-transformations">Custom transformations</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer" style="background-color:#181A1F"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/scalameta.png" alt="Scalameta" width="66" height="58"/></a><div><h5>Scalameta Docs</h5><a href=" /docs/trees/guide.html">Trees Guide</a><a href=" /docs/trees/quasiquotes.html">Quasiquotes</a><a href=" /docs/semanticdb/specification.html">SemanticDB</a></div><div><h5>Scalameta Projects</h5><a href="https://scalameta.org/metals">Metals: language server</a><a href="https://scalameta.org/scalafmt">Scalafmt: code formatter</a><a href="https://scalacenter.github.io/scalafix">Scalafix: linting and refactoring tool</a><a href="https://scalameta.org/munit">MUnit: testing library</a><a href="https://scalameta.org/mdoc">MDoc: documentation tool</a><a href="https://github.com/scalameta/metabrowse">Metabrowse: online code browser</a></div><div><h5>Community</h5><a href="https://github.com/scalameta/scalameta" target="_blank">GitHub</a><a href="https://github.com/scalameta/scalameta" target="_blank"><img src="https://img.shields.io/github/stars/scalameta/metals.svg?color=%23087e8b&amp;label=stars&amp;logo=github&amp;style=social"/></a><a href="https://discord.gg/RFpSVth" target="_blank"><img src="https://img.shields.io/discord/632642981228314653?logo=discord&amp;style=social"/></a><a href="https://gitter.im/scalameta/scalameta" target="_blank"><img src="https://img.shields.io/gitter/room/scalameta/scalameta.svg?logo=gitter&amp;style=social"/></a><a href="https://twitter.com/scalameta" target="_blank"><img src="https://img.shields.io/twitter/follow/scalameta.svg?logo=twitter&amp;style=social"/></a></div></section><section class="copyright">Copyright © 2022 Scalameta</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0460d1c693a278bc1ad07ada3fb96c63',
                indexName: 'scalameta',
                inputSelector: '#search_input_react'
              });
            </script></body></html>